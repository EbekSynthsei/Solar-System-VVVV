extern alias e3;
extern alias e2;

using n13 = e2::VL.Lib.Collections;
using n3 = _VL_Attractor_.Math;
using n4 = global::System.Collections.Generic;
using n11 = _CoreLibBasics_.Math.Adaptive;
using n7 = _CoreLibBasics_.Primitive.Advanced.Adaptive;
using n12 = _VL_Attractor_.Math.Attractor;
using n9 = e3::VL.Lib.Primitive;
using n6 = _CoreLibBasics_.Math.Ranges.Generic.Advanced;
using n1 = e2::VL.Core;
using n5 = _VL_Attractor_;
using n2 = global::System;
using n8 = e2::VL.Core.CompilerServices;
using n10 = global::System.Runtime.CompilerServices;
using n14 = _VL_Collections_.Collections.Spread;

namespace _VL_Attractor_.Math
{
    [n1.ElementAttribute(TracingId = 126U, DocumentId = "Tyv8gjorNaCMGFEbB0GPXx", PersistentId = "RbZMgBTKetoLbqL8OBESR0", Name = "Attractor_R")]
    [n2.SerializableAttribute]
    public class Attractor_R<T> : n1.VLObject, n2.IDisposable
    {
        [n8.CreateNewAttribute]
        public static n3.Attractor_R<T> Create<AdM>(n1.NodeContext Node_Context)
            where AdM : struct, n7.IAdaptiveCreateDefault<T>
        {
            Node_Context = Node_Context.WithIsImmutable(true);
            var instance = new Attractor_R<T>(Node_Context, n1.VLObject.NewIdentity());
            return instance.__Create__<AdM>(Node_Context);
        }

        [n8.CreateDefaultAttribute]
        public static n3.Attractor_R<T> CreateDefault<AdM>()
            where AdM : struct, n7.IAdaptiveCreateDefault<T>
        {
            return __DEFAULT__ ?? (__DEFAULT__ = __COMPUTE__());
            n3.Attractor_R<T> __COMPUTE__()
            {
                var context = n1.NodeContext.Default.WithIsImmutable(true);
                var instance = new Attractor_R<T>(context, n1.VLObject.NewIdentity());
                return instance.__CreateDefault__<AdM>();
            }
        }

        [n1.ElementAttribute(IsAutoGenerated = true)]
        public static n3.Attractor_R<T> __DEFAULT__;
        public n3.Attractor_R<T> Join(T Position_In, float Strength_In, float Power_In, float Radius_In)
        {
            T __auto_0 = Position_In;
            float __auto_1 = Strength_In;
            float __auto_2 = Power_In;
            float __auto_3 = Radius_In;
            n3.Attractor_R<T> that_4 = this;
            that_4 = !n4.EqualityComparer<T>.Default.Equals(Position_In, this.Position) || Strength_In != this.Strength || Power_In != this.Power || Radius_In != this.Radius ? new Attractor_R<T>(this)
            {Position = Position_In, Strength = Strength_In, Power = Power_In, Radius = Radius_In} : that_4;
            return that_4;
        }

        public n3.Attractor_R<T> Split(out T Position_Out, out float Strength_Out, out float Power_Out, out float Radius_Out)
        {
            T __auto_0 = this.Position;
            float __auto_1 = this.Strength;
            float __auto_2 = this.Power;
            float __auto_3 = this.Radius;
            Position_Out = __auto_0;
            Strength_Out = __auto_1;
            Power_Out = __auto_2;
            Radius_Out = __auto_3;
            return this;
        }

        public n3.Attractor_R<T> __Create__<AdM>(n1.NodeContext Node_Context)
            where AdM : struct, n7.IAdaptiveCreateDefault<T>
        {
            n10.RuntimeHelpers.EnsureSufficientExecutionStack();
            var w_0 = default(AdM);
            w_0.CreateDefault(out T __out_0);
            n3.Attractor_R<T> that_1 = this;
            this.Position = __out_0;
            this.Strength = 0F;
            this.Power = 0F;
            this.Radius = 0F;
            return that_1;
        }

        public n3.Attractor_R<T> __CreateDefault__<AdM>()
            where AdM : struct, n7.IAdaptiveCreateDefault<T>
        {
            var w_0 = default(AdM);
            w_0.CreateDefault(out T __out_1);
            n3.Attractor_R<T> that_1 = this;
            this.Position = __out_1;
            this.Strength = 0F;
            this.Power = 0F;
            this.Radius = 0F;
            return that_1;
        }

        public void Dispose()
        {
            return;
        }

        void n2.IDisposable.Dispose()
        {
            using var __current_services = __GetServiceRegistry__().MakeCurrentIfNone();
            Dispose();
        }

        [n1.ElementAttribute(TracingId = 128U, DocumentId = "Tyv8gjorNaCMGFEbB0GPXx", PersistentId = "BIFgBzbLXC9N8FQwlnuuXf", Name = "Position")]
        public T Position;
        [n1.ElementAttribute(TracingId = 129U, DocumentId = "Tyv8gjorNaCMGFEbB0GPXx", PersistentId = "DktVAsvpu5ULE2oeQAZdxa", Name = "Strength")]
        public float Strength;
        [n1.ElementAttribute(TracingId = 130U, DocumentId = "Tyv8gjorNaCMGFEbB0GPXx", PersistentId = "JzkG04gHBSaOnrKivraV2M", Name = "Power")]
        public float Power;
        [n1.ElementAttribute(TracingId = 131U, DocumentId = "Tyv8gjorNaCMGFEbB0GPXx", PersistentId = "EL25S6NPo8KQU7RApDN92n", Name = "Radius")]
        public float Radius;
        public Attractor_R(n1.NodeContext __context__, uint __identity__): base(__context__, __identity__)
        {
        }

        internal Attractor_R(Attractor_R<T> other): base(other)
        {
            this.Position = other.Position;
            this.Strength = other.Strength;
            this.Power = other.Power;
            this.Radius = other.Radius;
        }

        protected override n1.IVLObject __With__(n4.IReadOnlyDictionary<string, n2.Object> values)
        {
            return __WITH__(n1.CompilationHelper.GetValueOrExisting(values, "Position", in Position), n1.CompilationHelper.GetValueOrExisting(values, "Strength", in Strength), n1.CompilationHelper.GetValueOrExisting(values, "Power", in Power), n1.CompilationHelper.GetValueOrExisting(values, "Radius", in Radius));
        }

        internal Attractor_R<T> __WITH__(T Position, float Strength, float Power, float Radius)
        {
            n3.Attractor_R<T> that_0 = this;
            that_0 = !n4.EqualityComparer<T>.Default.Equals(Position, this.Position) || Strength != this.Strength || Power != this.Power || Radius != this.Radius ? new Attractor_R<T>(this)
            {Position = Position, Strength = Strength, Power = Power, Radius = Radius} : that_0;
            return that_0;
        }
    }

    [n1.ElementAttribute(TracingId = 463U, DocumentId = "Tyv8gjorNaCMGFEbB0GPXx", PersistentId = "Cdn0ulXXidfP7iWbaywnX8", Name = "VL_AttractorApplication_Cdn0ulXXidfP7iWbaywnX8")]
    [n2.SerializableAttribute]
    public class VL_AttractorApplication_Cdn0ulXXidfP7iWbaywnX8 : n1.VLObject, n2.IDisposable
    {
        [n8.CreateNewAttribute]
        public static n3.VL_AttractorApplication_Cdn0ulXXidfP7iWbaywnX8 Create(n1.NodeContext Node_Context)
        {
            var instance = new VL_AttractorApplication_Cdn0ulXXidfP7iWbaywnX8(Node_Context, n1.VLObject.NewIdentity());
            return instance.__Create__(Node_Context);
        }

        [n8.CreateDefaultAttribute]
        public static n3.VL_AttractorApplication_Cdn0ulXXidfP7iWbaywnX8 CreateDefault()
        {
            var instance = new VL_AttractorApplication_Cdn0ulXXidfP7iWbaywnX8(n1.NodeContext.Default, n1.VLObject.NewIdentity());
            return instance.__CreateDefault__();
        }

        public n3.VL_AttractorApplication_Cdn0ulXXidfP7iWbaywnX8 Update()
        {
            return this;
        }

        public n3.VL_AttractorApplication_Cdn0ulXXidfP7iWbaywnX8 __Create__(n1.NodeContext Node_Context)
        {
            n10.RuntimeHelpers.EnsureSufficientExecutionStack();
            return this;
        }

        public n3.VL_AttractorApplication_Cdn0ulXXidfP7iWbaywnX8 __CreateDefault__()
        {
            return this;
        }

        public void Dispose()
        {
            return;
        }

        void n2.IDisposable.Dispose()
        {
            using var __current_services = __GetServiceRegistry__().MakeCurrentIfNone();
            Dispose();
        }

        public VL_AttractorApplication_Cdn0ulXXidfP7iWbaywnX8(n1.NodeContext __context__, uint __identity__): base(__context__, __identity__)
        {
        }

        internal VL_AttractorApplication_Cdn0ulXXidfP7iWbaywnX8(VL_AttractorApplication_Cdn0ulXXidfP7iWbaywnX8 other): base(other)
        {
        }

        protected override n1.IVLObject __With__(n4.IReadOnlyDictionary<string, n2.Object> values)
        {
            return __WITH__();
        }

        internal VL_AttractorApplication_Cdn0ulXXidfP7iWbaywnX8 __WITH__()
        {
            return this;
        }
    }
}

namespace _VL_Attractor_.Math.Attractor
{
    [n1.ElementAttribute(TracingId = 123U, DocumentId = "Tyv8gjorNaCMGFEbB0GPXx", Name = "_Operations_")]
    public static partial class _Operations_
    {
        public static void Displace<T, AdM>(T Distance_In, float Length_In, [n8.SerializedDefaultValueAttribute("1", false)] float Strength_In, float Power_In, [n8.SerializedDefaultValueAttribute("1", false)] float Radius_In, out T Difference_Out)
            where AdM : struct, n11.IAdaptiveNormalize<T>, n11.IAdaptiveOperatorMulitply_Scale<T>
        {
            var w_0 = default(AdM);
            float __pad_Uapte4G9cN0LUD0XncVj5P_1 = __slot_Uapte4G9cN0LUD0XncVj5P;
            bool Apply_2 = true;
            var Output_3 = Distance_In;
            if (Apply_2)
            {
                w_0.Normalize(Input_In: Distance_In, Output_Out: out Output_3);
            }

            bool Apply_4 = true;
            var Output_5 = Length_In;
            if (Apply_4)
            {
                var Output_6 = (float)Length_In / Radius_In;
                Output_5 = Output_6;
            }

            bool Apply_7 = true;
            var Output_8 = Output_5;
            if (Apply_7)
            {
                n6._Operations_.Min<float, n5.__AdaptiveImplementations__Tyv8gjorNaCMGFEbB0GPXx>(Input_In: Output_5, Input_2_In: __pad_Uapte4G9cN0LUD0XncVj5P_1, Output_Out: out Output_8);
            }

            bool Apply_9 = true;
            var Output_10 = Output_8;
            if (Apply_9)
            {
                var Output_11 = n9.Float32Extensions.Pow(input: Output_8, exponent: Power_In);
                Output_10 = Output_11;
            }

            bool Apply_12 = true;
            var Output_13 = Output_10;
            if (Apply_12)
            {
                var Output_14 = Output_10 - Output_8;
                Output_13 = Output_14;
            }

            bool Apply_15 = true;
            var Output_16 = Strength_In;
            if (Apply_15)
            {
                var Output_17 = Strength_In * Output_13;
                Output_16 = Output_17;
            }

            bool Apply_18 = true;
            var Output_19 = Output_16;
            if (Apply_18)
            {
                var Output_20 = Output_16 * Radius_In;
                Output_19 = Output_20;
            }

            bool Apply_21 = true;
            var Output_22 = Output_3;
            if (Apply_21)
            {
                w_0.OperatorMulitply_Scale(Input_In: Output_3, Scalar_In: Output_19, Output_Out: out Output_22);
            }

            Difference_Out = Output_22;
            return;
        }

        public static void Attract<T, AdM>(T Point_In, n3.Attractor_R<T> Attractor_In, out T Point_Out)
            where AdM : struct, n11.IAdaptiveOperatorMinus<T>, n11.IAdaptiveNormalize<T>, n11.IAdaptiveOperatorMulitply_Scale<T>, n11.IAdaptiveOperatorPlus<T>, n11.IAdaptiveLength<T>
        {
            var w_0 = default(AdM);
            var Output_5 = Attractor_In.Split(Position_Out: out T Position_1, Strength_Out: out float Strength_2, Power_Out: out float Power_3, Radius_Out: out float Radius_4);
            bool Apply_6 = true;
            var Output_7 = Point_In;
            if (Apply_6)
            {
                w_0.OperatorMinus(Input_In: Point_In, Input_2_In: Position_1, Output_Out: out Output_7);
            }

            w_0.Length(Input_In: Output_7, Result_Out: out float Result_8);
            n12._Operations_.Displace<T, AdM>(Distance_In: Output_7, Length_In: Result_8, Strength_In: Strength_2, Power_In: Power_3, Radius_In: Radius_4, Difference_Out: out T Difference_9);
            bool Apply_10 = true;
            var Output_11 = Point_In;
            if (Apply_10)
            {
                w_0.OperatorPlus(Input_In: Point_In, Input_2_In: Difference_9, Output_Out: out Output_11);
            }

            Point_Out = Output_11;
            return;
        }

        public static void AttractByMany<T2, T, T3, AdM>(T2 Point_In, T3 Attractor_In, out n13.Spread<T> Point_Out)
            where T2 : n4.IEnumerable<T> where T3 : n4.IEnumerable<n3.Attractor_R<T>> where AdM : struct, n11.IAdaptiveOperatorMinus<T>, n7.IAdaptiveCreateDefault<T>, n11.IAdaptiveNormalize<T>, n11.IAdaptiveOperatorMulitply_Scale<T>, n11.IAdaptiveOperatorPlus<T>, n11.IAdaptiveLength<T>
        {
            n13.Spread<T> __cp_PM0aLRtqbsZPeVFicQmEp4 = n14._Operations_.CreateDefault<T>();
            var w_0 = default(AdM);
            n4.IEnumerable<n3.Attractor_R<T>> Input_1 = (n4.IEnumerable<n3.Attractor_R<T>>)Attractor_In;
            n14._Operations_.FromSequence<n3.Attractor_R<T>>(Input_In: Input_1, Result_Out: out n13.Spread<n3.Attractor_R<T>> Result_2);
            var builder_28 = n8.CollectionBuilders.GetBuilder(__cp_PM0aLRtqbsZPeVFicQmEp4, 16);
            n13.Spread<T> output_29;
            try
            {
                var i_5 = 0;
                foreach (var item_3 in Point_In)
                {
                    var splicer_4 = item_3;
                    var i_local_6 = i_5;
                    w_0.CreateDefault(Output_Out: out T Output_7);
                    T accumulator_9 = Output_7;
                    var i_11 = 0;
                    foreach (var item_8 in n8.CollectionExtensions.AsSpan(Result_2))
                    {
                        var splicer_10 = item_8;
                        var i_local_12 = i_11;
                        var Output_17 = splicer_10.Split(Position_Out: out T Position_13, Strength_Out: out float Strength_14, Power_Out: out float Power_15, Radius_Out: out float Radius_16);
                        bool Apply_18 = true;
                        var Output_19 = splicer_4;
                        if (Apply_18)
                        {
                            w_0.OperatorMinus(Input_In: splicer_4, Input_2_In: Position_13, Output_Out: out Output_19);
                        }

                        w_0.Length(Input_In: Output_19, Result_Out: out float Result_20);
                        var Result_21 = Result_20 < Radius_16;
                        T Difference_22;
                        if (Result_21)
                        {
                            n12._Operations_.Displace<T, AdM>(Distance_In: Output_19, Length_In: Result_20, Strength_In: Strength_14, Power_In: Power_15, Radius_In: Radius_16, Difference_Out: out T Difference_23);
                            bool Apply_24 = true;
                            var Output_25 = accumulator_9;
                            if (Apply_24)
                            {
                                w_0.OperatorPlus(Input_In: accumulator_9, Input_2_In: Difference_23, Output_Out: out Output_25);
                            }

                            Difference_22 = Output_25;
                        }
                        else
                        {
                            Difference_22 = accumulator_9;
                        }

                        accumulator_9 = Difference_22;
                        i_11++;
                    }

                    bool Apply_26 = true;
                    var Output_27 = splicer_4;
                    if (Apply_26)
                    {
                        w_0.OperatorPlus(Input_In: splicer_4, Input_2_In: accumulator_9, Output_Out: out Output_27);
                    }

                    builder_28.Add(Output_27);
                    i_5++;
                }
            }
            finally
            {
                output_29 = builder_28.Commit();
            }

            Point_Out = output_29;
            return;
        }

        [n1.ElementAttribute(TracingId = 157U, DocumentId = "Tyv8gjorNaCMGFEbB0GPXx", PersistentId = "Uapte4G9cN0LUD0XncVj5P", Name = "__slot_Uapte4G9cN0LUD0XncVj5P")]
        public static float __slot_Uapte4G9cN0LUD0XncVj5P = 1F;
        static _Operations_()
        {
        }
    }
}

namespace _VL_Attractor_
{
    public struct __AdaptiveImplementations__Tyv8gjorNaCMGFEbB0GPXx : n11.IAdaptiveOperatorLess<float>
    {
        public void OperatorLess(float Input_In, float Input_2_In, out bool Result_Out)
        {
            var Result_0 = Input_In < Input_2_In;
            Result_Out = Result_0;
            return;
        }
    }
}